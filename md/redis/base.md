### Redis集群

Redis集群模式

* 目前对于集群模式可用的方式有三个：
  * 最土的hash取模
  * 一致性哈希算法
  * 虚拟槽算法
* hash取模就是计算出key的hash值，对集群中节点数取模，得到要具体访问的节点。
  * 优点：简单粗暴
  * 缺点：当发生扩张和收缩时，数据迁移量过大，会导致下流服务扛不住，比如数据库。
* 一致性hash算法通过引入hash环，把节点分散到环上，请求时计算hash落在环上哪里，然后顺时针找寻第一个节点，去请求；为了保证节点尽可能分散开，还引入了虚节点，虚节点就像真实节点的分身，这样可以更好地分散开节点。
  * 优点：伸缩扩容迁移量仅涉及到某一段区间的数据迁移，节点数越多，迁移量越小。
  * 缺点：实现困难，且如果算法不合理，容易导致请求倾斜。
* Redis虚拟槽算法则是Redis作者提出的一种解决方案，通过定义16384个槽(为什么是这么多个是因为作者觉得不会超过这么多个实例，且越小网络带宽越少)来实现数据分散，一个实例负责一部分槽，key通过CRC16算法求得高效hash值，然后取模请求到具体的槽，再由槽背后的节点负责处理。
  * 优点：key和槽绑定，但是槽不和实例绑定，所以伸缩扩张过度平滑。数据迁移量由槽来确定，一般不会很多；实现简单。
  * 缺点：迁移期间数据可能暂时不可用，且需要良好的槽转移算法。



我单说虚拟槽算法的一些使用细节，因为实际中我们都是用的这个。

* 客户端自行计算key的hash值，然后得到槽，根据本地的槽-实例列表进行实例请求。
* 如果发生了实例变动，此时客户端不会主动更新，它去请求旧的实例时，旧的实例会返回MOVED指令，指出新的实例在哪；然后请求，并更新本地关系表。
* 如果此时数据还在迁移，会根据数据在哪进行分别处理；源节点会先在自己的数据库找，找到了直接返回，找不到返回一个ASK指出去哪找，然后客户端去请求，然后更新本地关系表。

这里需要说一下为什么会有MOVED和ASK两个，因为如果槽已经迁移完毕，则源节点肯定清除了这个槽，一个槽在任一时刻只能被一个节点负责，所以我们要“移动”；但是如果还在迁移，那这个槽处于分裂状态，一半半，所以需要特殊处理，特殊判断。