### HashMap/ConcurrentHashMap

HashMap

put()

* 判断桶数组是否初始化，如果未初始化执行初始化；
* 计算hash值并找到需要插入的位置，如果这个位置为空，直接插入: p = new Node(xxx...)；
* 使用一个临时变量equals指向冲突链中key和要插入的key一样的位置，当然也可能不存这样的位置。
* 如果第一个节点就是一样的话，则equals = node；否则判断冲突链是链表还是红黑树并进行相应的查找操作，找什么呢？找key和要插入的key一样的位置。
* 红黑树如果找不到会进行插入并返回空，链表也是，但是链表会顺便判断要不要树化。注意哈！链表是尾插。
* 最后判断equals如果是非空的话，进行value替换。
* 最最后判断要不要进行扩容。



初始化HashMap是通过resize()实现的。

resize()本身也蛮复杂的

* 判断容量是否大于默认值，是的话直接翻倍，然后是更新阈值等。
* 判断旧的桶数组是否为空，如果是的话就说明这是第一次初始化，也不用触发什么别的操作。
* 如果不是，则把旧的桶数组的元素迁移到新的桶数组中去，这里的迁移分为只有一个节点的直接迁移、红黑树迁移、链表迁移。
* 如果是只有一个节点的，直接计算下标迁移就行；
* 如果是红黑树，使用红黑树的split进行切分迁移；
* 如果是链表，遍历链表并计算新的下标进行迁移；这里的新下标其实就是根据节点的hash值&oldCap计算出是否等于0，如果是，说明在低位，还是原来的下标，如果不是，等于1，说明在高位，下标变成原来的下标+oldCap。

get()

* 根据hash找到下标。
* 判断是单一节点还是红黑树/链表；
* 执行相应的查找，红黑树树内查找，链表遍历；
* 找不到返回空。

remove()

* 计算下标；
* 判断节点类型，执行查找；
* 如果找不到结束；
* 找到了，判断节点类型，如果是直接节点，则直接删除；如果是链表，执行链表删除，即移动指针；如果是红黑树，执行树删除。

split()

* 这个方法是红黑树节点提供的操作，本身很简单。
* 遍历整个红黑树，计算节点属于低位节点还是高位节点。然后执行尾插，对没错，是链表的插入。
* 一切处理完，分别计算高位和低位是否需要树化或反树化，然后执行相关操作。

一些题外话，无论你传入的capacity是多少，最终都会化为2的倍数，这方便进行取模操作，即，可以把取模变成移位操作；同时引入了扰动函数，让尽可能多的位参与运算。



现在我们来看看ConcurrentHashMap

首先是JDK7版的。

new

* 这里的实例化会触发段数组的创建，段数组长度和HashMap的capacity有一样的规则，即必须是2的倍数，这样方便取模，化%为&

put()

* 计算hash值，对段数组长度取模得到具体是哪个段，即Segment；
* 如果segment未创建，则触发创建；
* 调用Segment#put()方法；
* 因为Segment继承自ReentrantLock，所以此时调用tryLock()方法，如果成功则：
  * 获取Segment#HashEntry并计算下标，找到需要插入的位置，这里称为Entry；
  * Entry可能是一个链表，所以我们遍历它，如果找到了相同的key，执行替换操作；
  * 如果找不到相同的key，触发头插法，但是插入之前会判断是否需要扩容，这里和HashMap不一样，HashMap是插入之后判断是否要扩容。
* 如果tryLock()失败了，会进入另一个方法: scanAndLockForPut()，在这个方法里我们干这个：
  * 在一个循环里进行重试，重试次数事先设定好。
    * 在第一个循环中进行要插入的节点构造，所以只会构造一次。
    * 如果循环期间有别的线程对HashEntry进行了更新，会导致重试次数重置。
    * 如果次数达到上限，使用lock()进行挂起。
* 释放锁。

get()

* 因为get不设计数据的更新，而且对于共享变量，ConcurrentHashMap使用volatile修饰，所以我们不需要加锁；
* 简单地找到需要查询的位置，查询即可，这个查询依旧是转发至Segment#get()去完成的。

remove()

* 因为涉及更新，所以需要加锁，但是流程和put差不多，不同的地方在于插入Entry变成了删除Entry。



JDK8的ConcurrentHashMap

put()

* 计算hash；
* 在一个死循环中进行，这个循环会不断获取Node[]；
  * 判断是否要初始化Node[]，如果需要，则触发初始化桶数组，这个方法下面会说；
  * 计算下标找到Node，判断Node是否是空，如果是，则CAS插入，成功break；
  * 失败判断是否在扩容，如果是，帮助扩容；
  * 如果没在扩容，使用synchronized(node) {}进行操作
    * 判断node是否被更改，如果被更改说明发生了扩容，此时重新开始循环；
    * 判断node类型是直接节点还是链表/红黑树，执行对应插入。尾插法
    * 是否需要树化。
* 是否需要扩容；

get()

* 因为不设计更新，且变量已使用volatile修饰，所以直接找到返回即可。

remove()

* 设计更新，过程类似put，但是把插入换成了删除。

initTable()

* 使用CAS替换sizeCtl参数，这个参数一开始为>=0，使用-1替换，如果替换成功，则初始化，构建桶数组，如果失败说明发生并发，让出CPU。

帮助扩容

* 扩容时并未跳出死循环，**这一点就保证了容器在扩容时并不会有其他线程进行数据添加操作，这也保证了容器的安全性**。